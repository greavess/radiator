% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detect_duplicate_genomes.R
\name{detect_duplicate_genomes}
\alias{detect_duplicate_genomes}
\title{Compute pairwise genome similarity or distance between individuals
to highligh potential duplicate individuals}
\usage{
detect_duplicate_genomes(
  data,
  interactive.filter = TRUE,
  detect.duplicate.genomes = TRUE,
  dup.threshold = 0,
  distance.method = "manhattan",
  genome = FALSE,
  threshold.common.markers = NULL,
  blacklist.duplicates = FALSE,
  parallel.core = parallel::detectCores() - 1,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{data}{(4 options) A file or object generated by radiator:
\itemize{
\item tidy data
\item Genomic Data Structure (GDS)
}

\emph{How to get GDS and tidy data ?}
Look into \code{\link{tidy_genomic_data}},
\code{\link{read_vcf}} or
\code{\link{tidy_vcf}}.}

\item{interactive.filter}{(optional, logical) Do you want the filtering session to
be interactive. Figures of distribution are shown before asking for filtering
thresholds.
Default: \code{interactive.filter = TRUE}.}

\item{detect.duplicate.genomes}{(optional, logical) For use inside radiator pipelines.
Default: \code{detect.duplicate.genomes = TRUE}.}

\item{dup.threshold}{Default: \code{dup.threshold = 0}. Turn off filter.}

\item{distance.method}{(character) Depending on input data, 2 different methods
are used (give similar results):
\itemize{
\item gds data The calculation is fast it's \code{SNPRelate::snpgdsIBS} under
the hood.
\item tidy data The distance measure uses \code{amap::Dist}.
This must be one of "euclidean", "maximum", "manhattan", "canberra", "binary".
}
Using \code{distance.method = NULL} will not run this method.
Default: \code{distance.method = "manhattan"}. This is very fast
compared to the genome similarity method. It uses allele counts and the codes
are tailored for biallelic and multiallelic markers.}

\item{genome}{(logical) Computes pairwise genome similarity in parallel.
The proportion of the shared genotypes is averaged across shared markers between
each pairwise comparison. This method makes filtering easier because the
threshold is more intuitive with the plots produced, but it's much longer
to run, even in parallel, so better to run overnight.
Default: \code{genome = FALSE}.}

\item{threshold.common.markers}{(double, optional) When using the
pairwise genome similarity approach (\code{genome = TRUE}), using a threshold
will filter the pairwise comparison before generating the results. This is
usefull if the number of pairwise comparisons (n*(n-1)/2) is very large and
allows to reduce the number of false positive, when missing data is involved.
e.g. 2 samples might have 100% markers in common, but if they only have
30% of their genotyped markers in common, this is a poor fit.
Default: \code{threshold.common.markers = NULL}.}

\item{blacklist.duplicates}{(optional, logical)
With \code{blacklist.duplicates = TRUE}, after visualization,
the user is asked to enter a threshold to filter out duplicates.
With default, \code{blacklist.duplicates = FALSE}, the function as no
interaction with user.}

\item{parallel.core}{(optional) The number of core used for parallel
execution during import.
Default: \code{parallel.core = parallel::detectCores() - 1}.}

\item{verbose}{(optional, logical) When \code{verbose = TRUE}
the function is a little more chatty during execution.
Default: \code{verbose = TRUE}.}

\item{...}{(optional) Advance mode that allows to pass further arguments
for fine-tuning the function. Also used for legacy arguments (see details or
special section)}
}
\value{
A list with potentially 8 objects:
\itemize{
\item \code{$distance }: results of the distance method.
\item \code{$distance.stats}: Summary statistics of the distance method.
\item \code{$pairwise.genome.similarity}: results of the genome method.
\item \code{$genome.stats}: Summary statistics of the genome method.
\item \code{$violin.plot.distance}: violin plot showing the distribution of pairwise distances.
\item \code{$manhattan.plot.distance}: same info different visual with manhattan plot.
\item \code{$violin.plot.genome}: violin plot showing the distribution of pairwise genome similarities.
\item \code{$manhattan.plot.genome}: same info different visual with manhattan plot.
\item \code{$blacklist.id.similar}: blacklisted duplicates.
}

Saved in the working directory:
individuals.pairwise.dist.tsv, individuals.pairwise.distance.stats.tsv,
individuals.pairwise.genome.similarity.tsv, individuals.pairwise.genome.stats.tsv,
blackliste.id.similar.tsv, blacklist.pairs.threshold.tsv
}
\description{
The function can compute two methods
to highligh potential duplicate individuals.
\enumerate{
\item distance between individuals and/or
\item pairwise genome similarity
}
}
\details{
Strategically, run the default first (\code{distance.method},
no \code{genome})

\strong{\code{distance.method} argument is fast, but...}

you don't know if the observed comparison (close or distant)
is influenced by missing values/the number of markers in common
between the pair compared. This is something that needs to be considered.
Be suspicious of a \emph{distant outlier} from the same pop pairwise comparison,
and similarly, be suspicious of a \emph{close outlier} from a different pop
pairwise comparisons.

If there is no outlier, don't bother running the function again with
(\code{genome = TRUE}).

\strong{Relative distance}

Is the normalized distance for your dataset (not calculated by strata). For
each individual, it's the distance divided by the maximum distance observed.
The range is limited between 0 and 1. Closer to 0 = the more similar and
closer to 1, the more distant.

\strong{\code{genome = TRUE}}

The function will run slower, but...
If you see outliers with the first run, take the time to run the function
with \code{genome = TRUE}. Because this option is much better at detecting
duplicated individuals and it also shows the impact of \strong{missingness}
or the number of \strong{shared markers} between comparisons.

\emph{Your outlier duo could well be the result of one of the individual having
an extremely low number of genotypes...}
}
\examples{
\dontrun{
# First run and simplest way (if you have the tidy tibble):
dup <- radiator::detect_duplicate_genomes(data = "wombat_tidy.rad")

# This will use by default:
# distance.method = "manhattan"
# genome = FALSE
# parallel.core = all my CPUs - 1

# If you need a tidy tibble: use one of radiator \code{tidy_} function or
# \code{radiator::tidy_genomic_data}


# To view the manhattan plot:
dup$manhattan.plot.distance

# to view the data stats
dup.data.stats <- dup$distance.stats

# to view the data
dup.data <- dup$distance

# Based on the look of the distribution using both manhattan and boxplot,
# I can filter the dataset to highlight potential duplicates.

# To run the distance (with euclidean distance instead of the default manhattan,
# and also carry the second analysis (with the genome method):
dup <- radiator::tidy_genomic_data(
    data = wombat_tidy_object,
    strata = "wombat.strata.tsv",
    vcf.metadata = FALSE
) \%>\%
radiator::detect_duplicate_genomes(
    data = .,
    distance.method = "euclidean",
    genome = TRUE
    )

# to view the data of the genome data
dup.data <- dup$pairwise.genome.similarity

# Based on the look of the distribution using both manhattan and boxplot,
# I can filter the dataset based on 98\% of identical genotype proportion,
# to highlight potential duplicates:
dup.filtered <- dplyr::filter(.data = dup.data, PROP_IDENTICAL > 0.98)

# Get the list of duplicates id
dup.list.names <- data.frame(INDIVIDUALS = unique(c(dup.filtered$ID1, dup.filtered$ID2)))
}
}
\author{
Thierry Gosselin \email{thierrygosselin@icloud.com}
}
